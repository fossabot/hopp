{"version":3,"sources":["../../src/fs/glob.js"],"names":["cache","require","debug","statCache","tempCache","pattern","cwd","useDoubleCache","relative","pttn","directory","recursive","length","curr","shift","localResults","recache","file","filepath","sep","fstat","isFile","hasOwnProperty","mtime","push","walk","concat","isDirectory","Array","undefined","val","process","env","RECACHE","results","Error","split"],"mappings":"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","file":"glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet statCache\nconst tempCache = {}\n\nexport default async (pattern, cwd, useDoubleCache = false, recache = false) => {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // get cache\n  if (statCache === undefined) {\n    statCache = cache.val('sc') || {}\n  }\n  \n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk(relative, pttn, directory, recursive = false) {\n    if (pttn.length === 0) {\n      return\n    }\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    debug('cwd = %s, relative = %s, curr: %s, dir = %s, recur = %s, recache = %s', cwd, relative, curr, directory, recursive, recache)\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      // has been modified\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache.hasOwnProperty(relative) || statCache[relative] !== +fstat.mtime) {\n            statCache[relative] = +fstat.mtime\n            localResults.push(filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(relative + path.sep + file, pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk(relative + path.sep + file, [curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    results = results.concat(await walk('.', pttn.split('/'), cwd))\n  }\n\n  /**\n   * Update cache.\n   */\n  cache.val('sc', statCache)\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n"]}