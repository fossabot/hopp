{"version":3,"sources":["../../src/hoppfile/load.js"],"names":["cache","file","Error","lmod","mtime","state","val","tasks","require","bustedTasks","task","hasOwnProperty","json","toJSON","Array"],"mappings":";;;;;;;;AAMA;;AACA;;IAAYA,K;;AACZ;;;;2cARA;;;;;;;uDAUe,iBAAMC,IAAN;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBAER,OAAOA,IAAP,KAAgB,QAFR;AAAA;AAAA;AAAA;;AAAA,kBAGL,IAAIC,KAAJ,CAAU,mBAAV,CAHK;;AAAA;AAAA;AAAA,mBAOQ,cAAKD,IAAL,CAPR;;AAAA;AAOPE,gBAPO,kBAOoBC,KAPpB;;;AASb;AACMC,iBAVO,GAUC,EAVD;AAAA,oBAWgBL,MAAMM,GAAN,CAAU,GAAV,KAAkB,EAXlC;AAAA;AAWXD,kBAAMF,IAXK;AAWCE,kBAAME,KAXP;;AAAA,kBAaTF,MAAMF,IAAN,KAAeA,IAbN;AAAA;AAAA;AAAA;;AAAA,6CAcJ,CAAC,IAAD,EAAO,EAAP,EAAWE,MAAME,KAAjB,CAdI;;AAAA;;AAiBb;AACMA,iBAlBO,GAkBCC,QAAQP,IAAR,CAlBD;;AAoBb;;AACAI,kBAAME,KAAN,GAAcF,MAAME,KAAN,IAAe,EAA7B;AACME,uBAtBO,GAsBO,EAtBP;;AAwBb;;AACA,iBAASC,IAAT,IAAiBH,KAAjB,EAAwB;AACtB,kBAAIA,MAAMI,cAAN,CAAqBD,IAArB,KAA8BL,MAAME,KAAN,CAAYI,cAAZ,CAA2BD,IAA3B,CAAlC,EAAoE;AAC5DE,oBAD4D,GACrDL,MAAMG,IAAN,EAAYG,MAAZ,EADqD;;;AAGlE,oBAAI,EAAED,gBAAgBE,KAAlB,KAA4B,CAAC,sBAAUF,IAAV,EAAgBP,MAAME,KAAN,CAAYG,IAAZ,CAAhB,CAAjC,EAAqE;AACnED,8BAAYC,IAAZ,IAAoB,IAApB;AACD;AACF;AACF;;AAED;AACAV,kBAAMM,GAAN,CAAU,GAAV,EAAe,CACbH,IADa,EAEbI,KAFa,CAAf;;AAKA;AAzCa,6CA0CN,CAAC,KAAD,EAAQE,WAAR,EAAqBF,KAArB,CA1CM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"load.js","sourcesContent":["/**\n * @file src/utils/load.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport { stat } from '../fs'\nimport * as cache from '../cache'\nimport { deepEqual } from '../utils'\n\nexport default async file => {\n  // if bad args die\n  if ( typeof file !== 'string' ) {\n    throw new Error('Unknown arguments')\n  }\n\n  // get file stat\n  const lmod = +(await stat(file)).mtime\n\n  // try to load from cache\n  const state = {}\n  ;[state.lmod, state.tasks] = cache.val('_') || []\n\n  if (state.lmod === lmod) {\n    return [true, {}, state.tasks]\n  }\n\n  // load via require\n  const tasks = require(file)\n\n  // figure out which tasks are bust\n  state.tasks = state.tasks || {}\n  const bustedTasks = {}\n\n  // only try checking for single tasks\n  for (let task in tasks) {\n    if (tasks.hasOwnProperty(task) && state.tasks.hasOwnProperty(task)) {\n      const json = tasks[task].toJSON()\n\n      if (!(json instanceof Array) && !deepEqual(json, state.tasks[task])) {\n        bustedTasks[task] = true\n      }\n    }\n  }\n\n  // cache exports\n  cache.val('_', [\n    lmod,\n    tasks\n  ])\n\n  // return exports\n  return [false, bustedTasks, tasks]\n}\n"]}