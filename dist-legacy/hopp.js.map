{"version":3,"sources":["../src/hopp.js"],"names":["require","debug","directory","plugName","tmp","basename","name","i","length","toUpperCase","prototype","d","stack","push","slice","call","arguments","forEach","init","src","all","watch"],"mappings":";;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;2cAVA;;;;;;eAYkBA,QAAQ,aAAR,EAAuB,MAAvB,C;IAAVC,K,YAAAA,K;;AAER;;;;;;uDAGe,iBAAMC,SAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACb,aADa;AAAA,mBACL,2BAAYA,SAAZ,CADK;;AAAA;AAAA,0BAC2B,gBAAQ;AAC9C,kBAAIC,WAAW,EAAf;;AAEA,mBAAK,IAAIC,MAAM,eAAKC,QAAL,CAAcC,IAAd,CAAV,EAA+BC,IAAI,CAAxC,EAA2CA,IAAIH,IAAII,MAAnD,EAA2DD,KAAK,CAAhE,EAAmE;AACjEJ,4BAAYC,IAAIG,CAAJ,MAAW,GAAX,GAAiBH,IAAIG,GAAJ,EAASE,WAAT,EAAjB,GAA0CL,IAAIG,CAAJ,CAAtD;AACD;;AAEDN,oBAAM,0BAAN,EAAkCE,QAAlC,EAA4CG,IAA5C;;AAEA;AACA;AACA,4BAAKI,SAAL,CAAeP,QAAf,IAA2B,YAAY;AACrC;AACA;AACA;AACA;;AAEA,qBAAKQ,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkB,CAChBP,IADgB,EAEhB,GAAGQ,KAAH,CAASC,IAAT,CAAcC,SAAd,CAFgB,CAAlB;;AAKA,uBAAO,IAAP;AACD,eAZD;AAaD,aAzBY;;AAAA,0BACmBC,OADnB;;AA2Bb;;;AAGMC,gBA9BO,GA8BA,SAAPA,IAAO;AAAA,qBAAO,kBAASC,GAAT,CAAP;AAAA,aA9BA;;AAgCbD,iBAAKE,GAAL;AACAF,iBAAKG,KAAL;;AAjCa,6CAmCNH,IAnCM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Create hopp object based on plugins.\n */\nexport default async directory => {\n  ;(await loadPlugins(directory)).forEach(name => {\n    let plugName = ''\n\n    for (let tmp = path.basename(name), i = 5; i < tmp.length; i += 1) {\n      plugName += tmp[i] === '-' ? tmp[i++].toUpperCase() : tmp[i]\n    }\n\n    debug('adding plugin %s from %s', plugName, name)\n    \n    // add the plugin to the hopp prototype so it can be\n    // used for the rest of the build process\n    Hopp.prototype[plugName] = function () {\n      // instead of actually loading the plugin at this stage,\n      // we will just pop its call into our internal call stack\n      // for use later. this is useful when we are stepping through\n      // an entire hoppfile but might only be running a single task\n\n      this.d.stack.push([\n        name,\n        [].slice.call(arguments)\n      ])\n\n      return this\n    }\n  })\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n  \n  init.all = createParallel\n  init.watch = createWatch\n\n  return init\n}\n"]}