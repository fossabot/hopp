{"version":3,"sources":["bundle.js"],"names":["Bundle","constructor","directory","fd","target","createWriteStream","autoClose","map","offset","files","sizes","status","buffers","flushIndex","id","Math","random","goal","add","file","stream","push","on","d","Buffer","isBuffer","body","from","length","Promise","resolve","reject","flush","then","relative","replace","write","concat","end","all","close"],"mappings":"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","file":"bundle.js","sourcesContent":["/**\n * @file src/streams/bundle.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport { EventEmitter } from 'events'\n\nexport default class Bundle extends EventEmitter {\n  constructor (directory, fd) {\n    super()\n\n    this.target = fs.createWriteStream(null, {\n      fd,\n      autoClose: false\n    })\n\n    this.map = {}\n    this.offset = 0\n    this.files = []\n    this.sizes = {}\n    this.status = {}\n    this.buffers = {}\n    this.flushIndex = 0\n    this.id = Math.random()\n    this.directory = directory\n\n    this.goal = []\n  }\n\n  add (file, stream) {\n    this.files.push(file)\n    this.buffers[file] = []\n    this.sizes[file] = 0\n    this.status[file] = false\n\n    stream.on('data', d => {\n      // in case it got stringified\n      if (!Buffer.isBuffer(d.body)) {\n        d.body = Buffer.from(d.body)\n      }\n\n      this.sizes[file] += d.body.length\n      this.buffers[file].push(d.body)\n    })\n\n    this.goal.push(new Promise((resolve, reject) => {\n      stream.on('error', reject)\n      stream.on('end', () => {\n        this.status[file] = true\n        this.flush().then(resolve, reject)\n      })\n    }))\n  }\n\n  /**\n   * Flush, in order.\n   */\n  async flush () {\n    const file = this.files[this.flushIndex]\n    const relative = file.replace(this.directory, '.')\n\n    if (this.status[file] && !this.map[relative]) {\n      // record sourcemap\n      this.map[relative] = [this.offset, this.offset + this.sizes[file]]\n      this.offset += this.sizes[file]\n\n      // write to file\n      await new Promise(resolve => {\n        this.target.write(Buffer.concat(this.buffers[file]), resolve)\n      })\n\n      // move to next\n      this.flushIndex++\n    }\n  }\n\n  end () {\n    return Promise.all(this.goal).then(async () => {\n      /**\n       * Ensure all data has been written.\n       */\n      while (this.flushIndex < this.files.length) {\n        await this.flush()\n      }\n\n      /**\n       * Close the bundle.\n       */\n      this.target.close()\n    })\n  }\n}\n"]}