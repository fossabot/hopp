{"version":3,"sources":["../../src/streams/bundle.js"],"names":["Bundle","constructor","directory","fd","target","createWriteStream","autoClose","map","offset","files","sizes","status","buffers","flushIndex","id","Math","random","goal","add","file","stream","push","on","d","Buffer","isBuffer","body","from","length","resolve","reject","flush","then","relative","replace","write","concat","end","close"],"mappings":"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","file":"../../src/streams/bundle.js","sourcesContent":["/**\n * @file src/streams/bundle.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport { EventEmitter } from 'events'\n\nexport default class Bundle extends EventEmitter {\n  constructor (directory, fd) {\n    super()\n\n    this.target = fs.createWriteStream(null, {\n      fd,\n      autoClose: false\n    })\n\n    this.map = {}\n    this.offset = 0\n    this.files = []\n    this.sizes = {}\n    this.status = {}\n    this.buffers = {}\n    this.flushIndex = 0\n    this.id = Math.random()\n    this.directory = directory\n\n    this.goal = []\n  }\n\n  add (file, stream) {\n    this.files.push(file)\n    this.buffers[file] = []\n    this.sizes[file] = 0\n    this.status[file] = false\n\n    stream.on('data', d => {\n      // in case it got stringified\n      if (!Buffer.isBuffer(d.body)) {\n        d.body = Buffer.from(d.body)\n      }\n\n      this.sizes[file] += d.body.length\n      this.buffers[file].push(d.body)\n    })\n\n    this.goal.push(new Promise((resolve, reject) => {\n      stream.on('error', reject)\n      stream.on('end', () => {\n        this.status[file] = true\n        this.flush().then(resolve, reject)\n      })\n    }))\n  }\n\n  /**\n   * Flush, in order.\n   */\n  async flush () {\n    const file = this.files[this.flushIndex]\n    const relative = file.replace(this.directory, '.')\n\n    if (this.status[file] && !this.map[relative]) {\n      // record sourcemap\n      this.map[relative] = [this.offset, this.offset + this.sizes[file]]\n      this.offset += this.sizes[file]\n\n      // write to file\n      await new Promise(resolve => {\n        this.target.write(Buffer.concat(this.buffers[file]), resolve)\n      })\n\n      // move to next\n      this.flushIndex++\n    }\n  }\n\n  end () {\n    return Promise.all(this.goal).then(async () => {\n      /**\n       * Ensure all data has been written.\n       */\n      while (this.flushIndex < this.files.length) {\n        await this.flush()\n      }\n\n      /**\n       * Close the bundle.\n       */\n      this.target.close()\n    })\n  }\n}\n"]}