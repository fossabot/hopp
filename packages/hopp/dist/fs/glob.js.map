{"version":3,"sources":["../../src/fs/glob.js"],"names":["cache","debug","require","statCache","tempCache","glob","pattern","cwd","useDoubleCache","recache","Array","undefined","val","console","log","process","env","RECACHE","walk","relative","pttn","directory","recursive","length","curr","shift","localResults","file","filepath","sep","relativepath","fstat","isFile","hasOwnProperty","mtime","push","concat","isDirectory","results","Error","nm","nonMagic","split","replace","substr","resolve","newpath","sub","indexOf"],"mappings":"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","file":"glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet statCache\nconst tempCache = {}\n\nasync function glob (pattern, cwd, useDoubleCache = false, recache = false) {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // get cache\n  if (statCache === undefined) {\n    statCache = cache.val('sc') || {}\n  }\n\n  console.log('cache at start: %j', statCache)\n\n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk (relative, pttn, directory, recursive = false) {\n    if (pttn.length === 0) {\n      return []\n    }\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    debug('cwd = %s, relative = %s, curr: %s, dir = %s, recur = %s, recache = %s', cwd, relative, curr, directory, recursive, recache)\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n      const relativepath = relative + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      debug('match(%s,%s) => %s', filepath, curr, match(file, curr))\n\n      // has been modified\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache.hasOwnProperty(relativepath) || statCache[relativepath] !== +fstat.mtime) {\n            statCache[relativepath] = +fstat.mtime\n            localResults.push(filepath)\n\n            debug('add: %s', filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(relative + path.sep + file, pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk(relative + path.sep + file, [curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    const nm = glob.nonMagic(pttn)\n    debug('nm = %j', nm)\n\n    if (!nm) {\n      results = results.concat(await walk(\n        '.',\n        pttn.split('/'),\n        cwd\n      ))\n    } else {\n      results = results.concat(await walk(\n        nm,\n        pttn.replace(nm, '').substr(1).split('/'),\n        path.resolve(cwd, nm)\n      ))\n    }\n  }\n\n  /**\n   * Update cache.\n   */\n  cache.val('sc', statCache)\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n\n/**\n * Get non-magical start of glob.\n * @param {String} pattern glob pattern\n * @returns {String} definitive path\n */\nglob.nonMagic = function (pattern) {\n  let newpath = ''\n\n  for (let sub of pattern.split('/')) {\n    if (sub) {\n      if (sub.indexOf('*') !== -1) {\n        break\n      }\n\n      newpath += path.sep + sub\n    }\n  }\n\n  return newpath.substr(1)\n}\n\nexport default glob\n"]}