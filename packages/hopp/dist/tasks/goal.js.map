{"version":3,"sources":["../../src/tasks/goal.js"],"names":["error","taskDefns","bustedTasks","fromArray","arr","defineTasks","defns","busted","create","tasks","projectDir","mode","setTimeout","process","exit","length","name","goal","Array","map","task"],"mappings":";;;;;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;;;AATA;;;;;;AAWA,MAAM,EAAEA,KAAF,KAAY,mBAAa,MAAb,CAAlB;;AAEA,IAAIC,SAAJ;AACA,IAAIC,WAAJ;;AAEA,SAASC,SAAT,CAAoBC,GAApB,EAAyB;AACvB,MAAIA,IAAI,CAAJ,MAAW,UAAf,EAA2B;AACzB,WAAO,wBAAeA,IAAI,CAAJ,CAAf,CAAP;AACD;;AAED,MAAIA,IAAI,CAAJ,MAAW,OAAf,EAAwB;AACtB,WAAO,qBAAYA,IAAI,CAAJ,CAAZ,CAAP;AACD;;AAED,SAAO,qBAAYA,IAAI,CAAJ,CAAZ,CAAP;AACD;;AAEM,MAAMC,oCAAc,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC5CN,cAAYK,KAAZ;AACAJ,gBAAcK,MAAd;;AAEA,kBAAYF,WAAZ,CAAwBC,KAAxB,EAA+BC,MAA/B;AACA,qBAAeF,WAAf,CAA2BC,KAA3B,EAAkCC,MAAlC;AACD,CANM;;AAQA,MAAMC,0BAAS,CAACC,KAAD,EAAQC,UAAR,EAAoBC,OAAO,OAA3B,KAAuC;AAC3D;;;AAGA,MAAIA,SAAS,OAAb,EAAsB;AACpBC,eAAW,MAAM;AACfZ,YAAM,mCAAN;AACAa,cAAQC,IAAR,CAAa,CAAC,CAAd;AACD,KAHD,EAGG,KAAK,EAAL,GAAU,IAHb;AAID;;AAED;;;AAGA,MAAIL,MAAMM,MAAN,KAAiB,CAArB,EAAwB;AACtB,QAAIC,OAAOP,MAAM,CAAN,CAAX;AACA,QAAIQ,OAAOhB,UAAUQ,MAAM,CAAN,CAAV,CAAX;;AAEA,QAAIQ,gBAAgBC,KAApB,EAA2B;AACzBD,aAAOd,UAAUc,IAAV,CAAP;AACD;;AAED,WAAOA,KAAKN,IAAL,EAAWK,IAAX,EAAiBN,UAAjB,EAA6B,CAAC,CAACR,YAAYc,IAAZ,CAA/B,CAAP;AACD;;AAED;;;AAGA,SAAO,mBAAYP,MAAMU,GAAN;AAAA,qCAAU,UAAMH,IAAN,EAAc;AACzC,UAAII,OAAOnB,UAAUe,IAAV,CAAX;;AAEA,UAAII,gBAAgBF,KAApB,EAA2B;AACzBE,eAAOjB,UAAUiB,IAAV,CAAP;AACD;;AAED,aAAOA,KAAKT,IAAL,EAAWK,IAAX,EAAiBN,UAAjB,EAA6B,CAAC,CAACR,YAAYc,IAAZ,CAA/B,CAAP;AACD,KARkB;;AAAA;AAAA;AAAA;AAAA,OAAZ,CAAP;AASD,CArCM","file":"../../src/tasks/goal.js","sourcesContent":["/**\n * @file src/tasks/mgr.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport createWatch from './watch'\nimport createSteps from './steps'\nimport createLogger from '../utils/log'\nimport createParallel from './parallel'\n\nconst { error } = createLogger('hopp')\n\nlet taskDefns\nlet bustedTasks\n\nfunction fromArray (arr) {\n  if (arr[0] === 'parallel') {\n    return createParallel(arr[1])\n  }\n\n  if (arr[0] === 'steps') {\n    return createSteps(arr[1])\n  }\n\n  return createWatch(arr[1])\n}\n\nexport const defineTasks = (defns, busted) => {\n  taskDefns = defns\n  bustedTasks = busted\n\n  createSteps.defineTasks(defns, busted)\n  createParallel.defineTasks(defns, busted)\n}\n\nexport const create = (tasks, projectDir, mode = 'start') => {\n  /**\n   * Set timeout for hung tasks.\n   */\n  if (mode === 'start') {\n    setTimeout(() => {\n      error('Timeout exceeded! A task is hung.')\n      process.exit(-1)\n    }, 10 * 60 * 1000)\n  }\n\n  /**\n   * If single task, don't bother wrapping with .all().\n   */\n  if (tasks.length === 1) {\n    let name = tasks[0]\n    let goal = taskDefns[tasks[0]]\n\n    if (goal instanceof Array) {\n      goal = fromArray(goal)\n    }\n\n    return goal[mode](name, projectDir, !!bustedTasks[name])\n  }\n\n  /**\n   * Otherwise wrap all.\n   */\n  return Promise.all(tasks.map(async name => {\n    let task = taskDefns[name]\n\n    if (task instanceof Array) {\n      task = fromArray(task)\n    }\n\n    return task[mode](name, projectDir, !!bustedTasks[name])\n  }))\n}\n"]}