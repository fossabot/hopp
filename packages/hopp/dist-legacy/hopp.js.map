{"version":3,"sources":["../src/hopp.js"],"names":["require","debug","directory","plugName","i","name","length","toUpperCase","prototype","d","stack","push","slice","call","arguments","forEach","init","src","all","steps","watch"],"mappings":";;;;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;eAEkBA,QAAQ,aAAR,EAAuB,MAAvB,C;IAAVC,K,YAAAA,K;;AAER;;;AAdA;;;;;;;8DAiBe,iBAAMC,SAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACb,aADa;AAAA,0CACL,2BAAYA,SAAZ,CADK;;AAAA;AAAA,0BAC2B,gBAAQ;AAC9C,kBAAIC,WAAW,EAAf;;AAEA;AACA,mBAAK,IAAIC,IAAI,EAAb,EAAiBA,IAAIC,KAAKC,MAA1B,EAAkCF,KAAK,CAAvC,EAA0C;AACxCD,4BAAYE,KAAKD,CAAL,MAAY,GAAZ,GAAkBC,KAAKD,GAAL,EAAUG,WAAV,EAAlB,GAA4CF,KAAKD,CAAL,CAAxD;AACD;;AAEDH,oBAAM,wBAAN,EAAgCI,IAAhC,EAAsCF,QAAtC;;AAEA;AACA;AACA,4BAAKK,SAAL,CAAeL,QAAf,IAA2B,YAAY;AACrC;AACA;AACA;AACA;;AAEA,qBAAKM,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkB,CAChBN,IADgB,EAEhB,GAAGO,KAAH,CAASC,IAAT,CAAcC,SAAd,CAFgB,CAAlB;;AAKA,uBAAO,IAAP;AACD,eAZD;AAaD,aA1BY;;AAAA,0BACmBC,OADnB;;AA4Bb;;;AAGMC,gBA/BO,GA+BA,SAAPA,IAAO;AAAA,qBAAO,kBAASC,GAAT,CAAP;AAAA,aA/BA;;AAiCbD,iBAAKE,GAAL;AACAF,iBAAKG,KAAL;AACAH,iBAAKI,KAAL;;AAnCa,6CAqCNJ,IArCM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"../src/hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport Hopp from './tasks/mgr'\nimport createSteps from './tasks/steps'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Create hopp object based on plugins.\n */\nexport default async directory => {\n  ;(await loadPlugins(directory)).forEach(name => {\n    let plugName = ''\n\n    // convert plugin name to camelcase\n    for (let i = 12; i < name.length; i += 1) {\n      plugName += name[i] === '-' ? name[i++].toUpperCase() : name[i]\n    }\n\n    debug('adding plugin %s as %s', name, plugName)\n\n    // add the plugin to the hopp prototype so it can be\n    // used for the rest of the build process\n    Hopp.prototype[plugName] = function () {\n      // instead of actually loading the plugin at this stage,\n      // we will just pop its call into our internal call stack\n      // for use later. this is useful when we are stepping through\n      // an entire hoppfile but might only be running a single task\n\n      this.d.stack.push([\n        name,\n        [].slice.call(arguments)\n      ])\n\n      return this\n    }\n  })\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n\n  init.all = createParallel\n  init.steps = createSteps\n  init.watch = createWatch\n\n  return init\n}\n"]}