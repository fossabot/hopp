{"version":3,"sources":["../../src/hoppfile/load.js"],"names":["cache","file","Error","lmod","mtime","state","val","tasks","require","bustedTasks","task","hasOwnProperty","json","toJSON","Array","resolve","test"],"mappings":";;;;;;;;AAMA;;IAAYA,K;;AACZ;;AACA;;;;2cARA;;;;;;;uDAUe,iBAAMC,IAAN;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBAET,OAAOA,IAAP,KAAgB,QAFP;AAAA;AAAA;AAAA;;AAAA,kBAGL,IAAIC,KAAJ,CAAU,mBAAV,CAHK;;AAAA;AAAA;AAAA,mBAOQ,cAAKD,IAAL,CAPR;;AAAA;AAOPE,gBAPO,kBAOoBC,KAPpB;;;AASb;AACMC,iBAVO,GAUC,EAVD;AAAA,oBAWgBL,MAAMM,GAAN,CAAU,GAAV,KAAkB,EAXlC;AAAA;AAWXD,kBAAMF,IAXK;AAWCE,kBAAME,KAXP;;AAAA,kBAaTF,MAAMF,IAAN,KAAeA,IAbN;AAAA;AAAA;AAAA;;AAAA,6CAcJ,CAAC,IAAD,EAAO,EAAP,EAAWE,MAAME,KAAjB,CAdI;;AAAA;;AAiBb;AACMA,iBAlBO,GAkBCC,QAAQP,IAAR,CAlBD;;AAoBb;;AACAI,kBAAME,KAAN,GAAcF,MAAME,KAAN,IAAe,EAA7B;AACME,uBAtBO,GAsBO,EAtBP;;AAwBb;;AACA,iBAASC,IAAT,IAAiBH,KAAjB,EAAwB;AACtB,kBAAIA,MAAMI,cAAN,CAAqBD,IAArB,KAA8BL,MAAME,KAAN,CAAYI,cAAZ,CAA2BD,IAA3B,CAAlC,EAAoE;AAC5DE,oBAD4D,GACrDL,MAAMG,IAAN,EAAYG,MAAZ,EADqD;;;AAGlE,oBAAI,EAAED,gBAAgBE,KAAlB,KAA4B,CAAC,sBAAUF,IAAV,EAAgBP,MAAME,KAAN,CAAYG,IAAZ,CAAhB,CAAjC,EAAqE;AACnED,8BAAYC,IAAZ,IAAoB,IAApB;AACD;AACF;AACF;;AAED;AAnCa,0BAoCbV,KApCa;AAAA,0BAuCX,aAvCW;AAAA;AAAA,mBAuCc,kBAASQ,QAAQO,OAAR,CAAgBd,IAAhB,CAAT,EAAgC,MAAhC,CAvCd;;AAAA;AAAA;;AAAA,6BAuCGe,IAvCH;AAAA;AAAA;AAAA;;AAAA;;AAyCX;AACI,aACA,CADA,EAEA,IAFA;;AAKF;AA/CS;AAAA;AAAA;;AAAA;AAAA,0BAgDP,CACAb,IADA,EAEAI,KAFA,CAhDO;;AAAA;AAAA;;AAAA,wBAoCPD,GApCO,mBAqCX,GArCW;;AAAA,6CAuDN,CAAC,KAAD,EAAQG,WAAR,EAAqBF,KAArB,CAvDM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"load.js","sourcesContent":["/**\n * @file src/utils/load.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport * as cache from '../cache'\nimport { deepEqual } from '../utils'\nimport { stat, readFile } from '../fs'\n\nexport default async file => {\n  // if bad args die\n  if (typeof file !== 'string') {\n    throw new Error('Unknown arguments')\n  }\n\n  // get file stat\n  const lmod = +(await stat(file)).mtime\n\n  // try to load from cache\n  const state = {}\n  ;[state.lmod, state.tasks] = cache.val('_') || []\n\n  if (state.lmod === lmod) {\n    return [true, {}, state.tasks]\n  }\n\n  // load via require\n  const tasks = require(file)\n\n  // figure out which tasks are bust\n  state.tasks = state.tasks || {}\n  const bustedTasks = {}\n\n  // only try checking for single tasks\n  for (let task in tasks) {\n    if (tasks.hasOwnProperty(task) && state.tasks.hasOwnProperty(task)) {\n      const json = tasks[task].toJSON()\n\n      if (!(json instanceof Array) && !deepEqual(json, state.tasks[task])) {\n        bustedTasks[task] = true\n      }\n    }\n  }\n\n  // cache exports\n  cache.val(\n    '_',\n\n    /function|=>/.test(await readFile(require.resolve(file), 'utf8'))\n\n    // if any functions exist, we can't cache the file\n      ? [\n        0,\n        null\n      ]\n\n      // otherwise, cache normally\n      : [\n        lmod,\n        tasks\n      ]\n  )\n\n  // return exports\n  return [false, bustedTasks, tasks]\n}\n"]}