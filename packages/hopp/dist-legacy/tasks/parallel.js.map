{"version":3,"sources":["../../src/tasks/parallel.js"],"names":["MAX_JOBS","cpus","length","debug","taskTree","bustedTasks","runParallel","jobs","tasks","name","directory","Promise","resolve","reject","isMaster","i","fork","JOB_START","JOB_SIZE","tasksPerJob","Math","floor","ndone","on","id","code","Error","min","FIRST_JOB","parseInt","process","env","LAST_JOB","subtasks","slice","runAsync","then","exit","catch","console","error","err","stack","all","map","runTask","task","start","parallel","WEB_CONCURRENCY","isNaN","watch","toJSON","defineTasks","defns","busted"],"mappings":"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","file":"parallel.js","sourcesContent":["/**\n * @file src/plugins/parallel.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport os from 'os'\nimport cluster from 'cluster'\nimport { createLogger } from '../utils'\n\nconst MAX_JOBS = os.cpus().length\nconst { debug } = createLogger('hopp')\n\nlet taskTree\nlet bustedTasks\n\n/**\n * Run all tasks in parallel.\n */\nfunction runParallel (jobs, tasks, name, directory) {\n  return new Promise((resolve, reject) => {\n    if (cluster.isMaster) {\n      if (tasks.length < jobs) {\n        debug('starting %s jobs, 1 task per job', tasks.length)\n\n        for (let i = 0; i < tasks.length; i++) {\n          cluster.fork({\n            JOB_START: i,\n            JOB_SIZE: 1\n          })\n        }\n      } else {\n        const tasksPerJob = Math.floor(tasks.length / jobs)\n        debug('starting %s jobs, %s tasks per job', jobs, tasksPerJob)\n\n        // start all but last job\n        for (let i = 0; i < jobs; i++) {\n          cluster.fork({\n            JOB_START: i * tasksPerJob,\n            JOB_SIZE: i === MAX_JOBS - 1 ? MAX_JOBS - (tasksPerJob * (i - 1)) : tasksPerJob\n          })\n        }\n      }\n\n      // wait for the end of all the jobs\n      let ndone = 0\n\n      cluster.on('exit', (id, code) => {\n        ndone++\n\n        // if any worker fails, reject the promise\n        if (code !== 0) {\n          return reject(new Error(`Job ${id} failed.`))\n        }\n\n        // once all workers successfully return, resolve promise\n        if (ndone === Math.min(tasks.length, jobs)) {\n          resolve()\n        }\n      })\n    } else {\n      const FIRST_JOB = parseInt(process.env.JOB_START, 10)\n      const LAST_JOB = parseInt(process.env.JOB_START, 10) + parseInt(process.env.JOB_SIZE, 10)\n\n      // grab slice of tasks that this worker should do\n      const subtasks = tasks.slice(FIRST_JOB, LAST_JOB)\n\n      // run in async\n      runAsync(subtasks, name, directory)\n        .then(() => process.exit(0))\n        .catch(err => {\n          console.error(err && err.stack ? err.stack : err)\n          process.exit(-1)\n        })\n    }\n  })\n}\n\n/**\n * Run all tasks in async.\n */\nfunction runAsync (tasks, name, directory) {\n  // just async for now\n  debug('running %s tasks in async', tasks.length)\n  return Promise.all(tasks.map(\n    task => runTask(task, name, directory)\n  ))\n}\n\n/**\n * Run individual task.\n */\nfunction runTask (task, name, directory) {\n  return taskTree[task].start(`${name}:${task}`, directory, !!bustedTasks[task])\n}\n\n/**\n * Creates a Hopp-ish object that runs\n * subtasks in parallel.\n */\nconst parallel = tasks => ({\n  /**\n   * Starts all tasks concurrently.\n   *\n   * @return {Promise} joins all task promises under .all()\n   */\n  start (name, directory) {\n    let jobs = parseInt(process.env.WEB_CONCURRENCY)\n\n    // if jobs not specified, just stick to async\n    if (isNaN(jobs)) return runAsync(tasks, name, directory)\n\n    // disallow negatives\n    if (jobs < 0) throw new Error('Negative number of jobs not supported.')\n\n    // if zero, assume max\n    if (jobs === 0) jobs = MAX_JOBS\n\n    // run parallel\n    return runParallel(jobs, tasks, name, directory)\n  },\n\n  /**\n   * Watch all subtasks.\n   */\n  watch (name, directory) {\n    return Promise.all(tasks.map(task => {\n      return taskTree[task].watch(name + ':' + task, directory)\n    }))\n  },\n\n  /**\n   * Converts tasks to JSON.\n   * Just converts them into an tasksay of\n   * JSON objects.\n   *\n   * @return {tasksay}\n   */\n  toJSON () {\n    return ['parallel', tasks]\n  }\n})\n\nparallel.defineTasks = (defns, busted) => {\n  taskTree = defns\n  bustedTasks = busted\n}\n\nexport default parallel\n"]}