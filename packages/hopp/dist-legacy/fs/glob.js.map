{"version":3,"sources":["glob.js"],"names":["pattern","cwd","useDoubleCache","relative","pttn","directory","recursive","debug","recache","length","slice","curr","shift","localResults","file","filepath","sep","relativepath","fstat","tempCache","isFile","mtime","statCache","hasOwnProperty","push","walk","concat","isDirectory","Array","undefined","cache","val","process","env","RECACHE","results","Error","nm","glob","nonMagic","split","replace","substr","resolve","require","newpath","sub","indexOf"],"mappings":"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","file":"glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet statCache\nconst tempCache = {}\n\nasync function glob (pattern, cwd, useDoubleCache = false, recache = false) {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // get cache\n  if (statCache === undefined) {\n    statCache = cache.val('sc') || {}\n  }\n\n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk (relative, pttn, directory, recursive = false) {\n    debug('walk(relative = %s, pttn = %s, directory = %s, recursive = %s) in %s [recache:%s, curr:%s]', relative, pttn, directory, recursive, cwd, recache, pttn[0])\n\n    if (pttn.length === 0) {\n      return []\n    }\n\n    pttn = pttn.slice()\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n      const relativepath = relative + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      debug('match(%s,%s) => %s [%s]', filepath, curr, match(file, curr), fstat.isFile() ? 'file' : 'dir')\n\n      // has been modified\n      debug('stat(%s) :: %s', +fstat.mtime, statCache[relativepath])\n\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache.hasOwnProperty(relativepath) || statCache[relativepath] !== +fstat.mtime) {\n            statCache[relativepath] = +fstat.mtime\n            localResults.push(filepath)\n\n            debug('add: %s', filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(relativepath, pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk(relativepath, [curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    const nm = glob.nonMagic(pttn)\n    debug('nm = %j', nm)\n\n    if (!nm) {\n      results = results.concat(await walk(\n        '.',\n        pttn.split('/'),\n        cwd\n      ))\n    } else {\n      results = results.concat(await walk(\n        nm,\n        pttn.replace(nm, '').substr(1).split('/'),\n        path.resolve(cwd, nm)\n      ))\n    }\n  }\n\n  /**\n   * Update cache.\n   */\n  cache.val('sc', statCache)\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n\n/**\n * Get non-magical start of glob.\n * @param {String} pattern glob pattern\n * @returns {String} definitive path\n */\nglob.nonMagic = function (pattern) {\n  let newpath = ''\n\n  for (let sub of pattern.split('/')) {\n    if (sub) {\n      if (sub.indexOf('*') !== -1) {\n        break\n      }\n\n      newpath += path.sep + sub\n    }\n  }\n\n  return newpath.substr(1)\n}\n\nexport default glob\n"]}