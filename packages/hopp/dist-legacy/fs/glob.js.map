{"version":3,"sources":["../../src/fs/glob.js"],"names":["pattern","cwd","useDoubleCache","relative","pttn","directory","recursive","length","curr","shift","localResults","debug","recache","file","filepath","sep","fstat","tempCache","isFile","statCache","hasOwnProperty","mtime","push","walk","concat","isDirectory","Array","undefined","cache","val","process","env","RECACHE","results","Error","nm","glob","nonMagic","split","replace","substr","resolve","require","newpath","sub","indexOf"],"mappings":"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","file":"glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet statCache\nconst tempCache = {}\n\nasync function glob (pattern, cwd, useDoubleCache = false, recache = false) {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // get cache\n  if (statCache === undefined) {\n    statCache = cache.val('sc') || {}\n  }\n\n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk (relative, pttn, directory, recursive = false) {\n    if (pttn.length === 0) {\n      return []\n    }\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    debug('cwd = %s, relative = %s, curr: %s, dir = %s, recur = %s, recache = %s', cwd, relative, curr, directory, recursive, recache)\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      // has been modified\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache.hasOwnProperty(relative) || statCache[relative] !== +fstat.mtime) {\n            statCache[relative] = +fstat.mtime\n            localResults.push(filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(relative + path.sep + file, pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk(relative + path.sep + file, [curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    const nm = glob.nonMagic(pttn)\n\n    if (nm === '.') {\n      results = results.concat(await walk(\n        '.',\n        pttn.split('/'),\n        cwd\n      ))\n    } else {\n      results = results.concat(await walk(\n        nm,\n        pttn.replace(nm, '').substr(1).split('/'),\n        path.resolve(cwd, nm)\n      ))\n    }\n  }\n\n  /**\n   * Update cache.\n   */\n  cache.val('sc', statCache)\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n\n/**\n * Get non-magical start of glob.\n * @param {String} pattern glob pattern\n * @returns {String} definitive path\n */\nglob.nonMagic = function (pattern) {\n  let newpath = ''\n\n  for (let sub of pattern.split('/')) {\n    if (sub) {\n      if (sub.indexOf('*') !== -1) {\n        break\n      }\n\n      newpath += path.sep + sub\n    }\n  }\n\n  return newpath.substr(1)\n}\n\nexport default glob\n"]}