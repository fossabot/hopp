{"version":3,"sources":["../../src/streams/bundle.js"],"names":["Bundle","constructor","fd","target","createWriteStream","autoClose","map","offset","files","sizes","status","buffers","flushIndex","id","Math","random","goal","add","file","stream","push","on","d","Buffer","isBuffer","body","from","length","Promise","resolve","reject","flush","then","write","concat","end","all","close"],"mappings":";;;;;;AAMA;;;;AACA;;;;AAPA;;;;;;AASA,MAAMA,MAAN,8BAAkC;AAChCC,cAAaC,EAAb,EAAiB;AACf;;AAEA,SAAKC,MAAL,GAAc,aAAGC,iBAAH,CAAqB,IAArB,EAA2B;AACvCF,QADuC;AAEvCG,iBAAW;AAF4B,KAA3B,CAAd;;AAKA,SAAKC,GAAL,GAAW,EAAX;AACA,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,EAAL,GAAUC,KAAKC,MAAL,EAAV;;AAEA,SAAKC,IAAL,GAAY,EAAZ;AACD;;AAEDC,MAAKC,IAAL,EAAWC,MAAX,EAAmB;AACjB,SAAKX,KAAL,CAAWY,IAAX,CAAgBF,IAAhB;AACA,SAAKP,OAAL,CAAaO,IAAb,IAAqB,EAArB;AACA,SAAKT,KAAL,CAAWS,IAAX,IAAmB,CAAnB;AACA,SAAKR,MAAL,CAAYQ,IAAZ,IAAoB,KAApB;;AAEAC,WAAOE,EAAP,CAAU,MAAV,EAAkBC,KAAK;AACrB;AACA,UAAI,CAACC,OAAOC,QAAP,CAAgBF,EAAEG,IAAlB,CAAL,EAA8B;AAC5BH,UAAEG,IAAF,GAASF,OAAOG,IAAP,CAAYJ,EAAEG,IAAd,CAAT;AACD;;AAED,WAAKhB,KAAL,CAAWS,IAAX,KAAoBI,EAAEG,IAAF,CAAOE,MAA3B;AACA,WAAKhB,OAAL,CAAaO,IAAb,EAAmBE,IAAnB,CAAwBE,EAAEG,IAA1B;AACD,KARD;;AAUA,SAAKT,IAAL,CAAUI,IAAV,CAAe,IAAIQ,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC9CX,aAAOE,EAAP,CAAU,OAAV,EAAmBS,MAAnB;AACAX,aAAOE,EAAP,CAAU,KAAV,EAAiB,MAAM;AACrB,aAAKX,MAAL,CAAYQ,IAAZ,IAAoB,IAApB;AACA,aAAKa,KAAL,GAAaC,IAAb,CAAkBH,OAAlB,EAA2BC,MAA3B;AACD,OAHD;AAID,KANc,CAAf;AAOD;;AAED;;;AAGA,QAAMC,KAAN,GAAe;AACb,UAAMb,OAAO,KAAKV,KAAL,CAAW,KAAKI,UAAhB,CAAb;;AAEA,QAAI,KAAKF,MAAL,CAAYQ,IAAZ,KAAqB,CAAC,KAAKZ,GAAL,CAASY,IAAT,CAA1B,EAA0C;AACxC;AACA,WAAKZ,GAAL,CAASY,IAAT,IAAiB,CAAC,KAAKX,MAAN,EAAc,KAAKA,MAAL,GAAc,KAAKE,KAAL,CAAWS,IAAX,CAA5B,CAAjB;AACA,WAAKX,MAAL,IAAe,KAAKE,KAAL,CAAWS,IAAX,CAAf;;AAEA;AACA,YAAM,IAAIU,OAAJ,CAAYC,WAAW;AAC3B,aAAK1B,MAAL,CAAY8B,KAAZ,CAAkBV,OAAOW,MAAP,CAAc,KAAKvB,OAAL,CAAaO,IAAb,CAAd,CAAlB,EAAqDW,OAArD;AACD,OAFK,CAAN;;AAIA;AACA,WAAKjB,UAAL;AACD;AACF;;AAEDuB,QAAO;AACL,WAAOP,QAAQQ,GAAR,CAAY,KAAKpB,IAAjB,EAAuBgB,IAAvB,CAA4B,YAAY;AAC7C;;;AAGA,aAAO,KAAKpB,UAAL,GAAkB,KAAKJ,KAAL,CAAWmB,MAApC,EAA4C;AAC1C,cAAM,KAAKI,KAAL,EAAN;AACD;;AAED;;;AAGA,WAAK5B,MAAL,CAAYkC,KAAZ;AACD,KAZM,CAAP;AAaD;AAjF+B;;kBAoFnBnC,MAAM,IAAIF,MAAJ,CAAWE,EAAX,C","file":"bundle.js","sourcesContent":["/**\n * @file src/streams/bundle.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport { EventEmitter } from 'events'\n\nclass Bundle extends EventEmitter {\n  constructor (fd) {\n    super()\n\n    this.target = fs.createWriteStream(null, {\n      fd,\n      autoClose: false\n    })\n\n    this.map = {}\n    this.offset = 0\n    this.files = []\n    this.sizes = {}\n    this.status = {}\n    this.buffers = {}\n    this.flushIndex = 0\n    this.id = Math.random()\n\n    this.goal = []\n  }\n\n  add (file, stream) {\n    this.files.push(file)\n    this.buffers[file] = []\n    this.sizes[file] = 0\n    this.status[file] = false\n\n    stream.on('data', d => {\n      // in case it got stringified\n      if (!Buffer.isBuffer(d.body)) {\n        d.body = Buffer.from(d.body)\n      }\n\n      this.sizes[file] += d.body.length\n      this.buffers[file].push(d.body)\n    })\n\n    this.goal.push(new Promise((resolve, reject) => {\n      stream.on('error', reject)\n      stream.on('end', () => {\n        this.status[file] = true\n        this.flush().then(resolve, reject)\n      })\n    }))\n  }\n\n  /**\n   * Flush, in order.\n   */\n  async flush () {\n    const file = this.files[this.flushIndex]\n\n    if (this.status[file] && !this.map[file]) {\n      // record sourcemap\n      this.map[file] = [this.offset, this.offset + this.sizes[file]]\n      this.offset += this.sizes[file]\n\n      // write to file\n      await new Promise(resolve => {\n        this.target.write(Buffer.concat(this.buffers[file]), resolve)\n      })\n\n      // move to next\n      this.flushIndex ++\n    }\n  }\n\n  end () {\n    return Promise.all(this.goal).then(async () => {\n      /**\n       * Ensure all data has been written.\n       */\n      while (this.flushIndex < this.files.length) {\n        await this.flush()\n      }\n\n      /**\n       * Close the bundle.\n       */\n      this.target.close()\n    })\n  }\n}\n\nexport default fd => new Bundle(fd)\n"]}