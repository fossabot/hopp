{"version":3,"sources":["../../src/tasks/parallel.js"],"names":["MAX_JOBS","cpus","length","debug","taskTree","bustedTasks","runParallel","jobs","tasks","name","directory","Promise","resolve","reject","isMaster","i","fork","JOB_START","JOB_SIZE","tasksPerJob","Math","floor","ndone","on","id","code","Error","min","FIRST_JOB","parseInt","process","env","LAST_JOB","subtasks","slice","runAsync","then","exit","catch","err","console","error","stack","all","map","task","runTask","start","parallel","WEB_CONCURRENCY","isNaN","toJSON","defineTasks","defns","busted"],"mappings":"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","file":"parallel.js","sourcesContent":["/**\n * @file src/plugins/parallel.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport os from 'os'\nimport cluster from 'cluster'\nimport { createLogger } from '../utils'\n\nconst MAX_JOBS = os.cpus().length\nconst { debug } = createLogger('hopp')\n\nlet taskTree\nlet bustedTasks\n\n/**\n * Run all tasks in parallel.\n */\nfunction runParallel (jobs, tasks, name, directory) {\n  return new Promise((resolve, reject) => {\n    if (cluster.isMaster) {\n      if (tasks.length < jobs) {\n        debug('starting %s jobs, 1 task per job', tasks.length)\n\n        for (let i = 0; i < tasks.length; i++) {\n          cluster.fork({\n            JOB_START: i,\n            JOB_SIZE: 1\n          })\n        }\n      } else {\n        const tasksPerJob = Math.floor(tasks.length / jobs)\n        debug('starting %s jobs, %s tasks per job', jobs, tasksPerJob)\n\n        // start all but last job\n        for (let i = 0; i < jobs; i++) {\n          cluster.fork({\n            JOB_START: i * tasksPerJob,\n            JOB_SIZE: i === MAX_JOBS - 1 ? MAX_JOBS - (tasksPerJob * (i - 1)) : tasksPerJob\n          })\n        }\n      }\n\n      // wait for the end of all the jobs\n      let ndone = 0\n\n      cluster.on('exit', (id, code) => {\n        ndone++\n\n        // if any worker fails, reject the promise\n        if (code !== 0) {\n          return reject(new Error(`Job ${id} failed.`))\n        }\n\n        // once all workers successfully return, resolve promise\n        if (ndone === Math.min(tasks.length, jobs)) {\n          resolve()\n        }\n      })\n    } else {\n      const FIRST_JOB = parseInt(process.env.JOB_START, 10)\n      const LAST_JOB = parseInt(process.env.JOB_START, 10) + parseInt(process.env.JOB_SIZE, 10)\n\n      // grab slice of tasks that this worker should do\n      const subtasks = tasks.slice(FIRST_JOB, LAST_JOB)\n\n      // run in async\n      runAsync(subtasks, name, directory)\n        .then(() => process.exit(0))\n        .catch(err => {\n          console.error(err && err.stack ? err.stack : err)\n          process.exit(-1)\n        })\n    }\n  })\n}\n\n/**\n * Run all tasks in async.\n */\nfunction runAsync (tasks, name, directory) {\n  // just async for now\n  debug('running %s tasks in async', tasks.length)\n  return Promise.all(tasks.map(\n    task => runTask(task, name, directory)\n  ))\n}\n\n/**\n * Run individual task.\n */\nfunction runTask (task, name, directory) {\n  return taskTree[task].start(`${name}:${task}`, directory, !!bustedTasks[task])\n}\n\n/**\n * Creates a Hopp-ish object that runs\n * subtasks in parallel.\n */\nconst parallel = tasks => ({\n  /**\n   * Starts all tasks concurrently.\n   *\n   * @return {Promise} joins all task promises under .all()\n   */\n  start (name, directory) {\n    let jobs = parseInt(process.env.WEB_CONCURRENCY)\n\n    // if jobs not specified, just stick to async\n    if (isNaN(jobs)) return runAsync(tasks, name, directory)\n\n    // disallow negatives\n    if (jobs < 0) throw new Error('Negative number of jobs not supported.')\n\n    // if zero, assume max\n    if (jobs === 0) jobs = MAX_JOBS\n\n    // run parallel\n    return runParallel(jobs, tasks, name, directory)\n  },\n\n  /**\n   * Converts tasks to JSON.\n   * Just converts them into an tasksay of\n   * JSON objects.\n   *\n   * @return {tasksay}\n   */\n  toJSON () {\n    return ['parallel', tasks]\n  }\n})\n\nparallel.defineTasks = (defns, busted) => {\n  taskTree = defns\n  bustedTasks = busted\n}\n\nexport default parallel\n"]}