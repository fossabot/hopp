{"version":3,"sources":["../src/hopp.js"],"names":["debug","require","directory","forEach","name","plugName","i","length","toUpperCase","prototype","d","stack","push","slice","call","arguments","init","src","all","watch"],"mappings":";;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,MAAM,EAAEA,KAAF,KAAYC,QAAQ,aAAR,EAAuB,MAAvB,CAAlB;;AAEA;;;AAdA;;;;;;kBAiBe,MAAMC,SAAN,IAAmB;AAChC,GAAC,CAAC,MAAM,2BAAYA,SAAZ,CAAP,EAA+BC,OAA/B,CAAuCC,QAAQ;AAC9C,QAAIC,WAAW,EAAf;;AAEA;AACA,SAAK,IAAIC,IAAI,EAAb,EAAiBA,IAAIF,KAAKG,MAA1B,EAAkCD,KAAK,CAAvC,EAA0C;AACxCD,kBAAYD,KAAKE,CAAL,MAAY,GAAZ,GAAkBF,KAAKE,GAAL,EAAUE,WAAV,EAAlB,GAA4CJ,KAAKE,CAAL,CAAxD;AACD;;AAEDN,UAAM,wBAAN,EAAgCI,IAAhC,EAAsCC,QAAtC;;AAEA;AACA;AACA,kBAAKI,SAAL,CAAeJ,QAAf,IAA2B,YAAY;AACrC;AACA;AACA;AACA;;AAEA,WAAKK,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkB,CAChBR,IADgB,EAEhB,GAAGS,KAAH,CAASC,IAAT,CAAcC,SAAd,CAFgB,CAAlB;;AAKA,aAAO,IAAP;AACD,KAZD;AAaD,GAzBA;;AA2BD;;;AAGA,QAAMC,OAAOC,OAAO,kBAASA,GAAT,CAApB;;AAEAD,OAAKE,GAAL;AACAF,OAAKG,KAAL;;AAEA,SAAOH,IAAP;AACD,C","file":"hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Create hopp object based on plugins.\n */\nexport default async directory => {\n  ;(await loadPlugins(directory)).forEach(name => {\n    let plugName = ''\n\n    // convert plugin name to camelcase\n    for (let i = 12; i < name.length; i += 1) {\n      plugName += name[i] === '-' ? name[i++].toUpperCase() : name[i]\n    }\n\n    debug('adding plugin %s as %s', name, plugName)\n    \n    // add the plugin to the hopp prototype so it can be\n    // used for the rest of the build process\n    Hopp.prototype[plugName] = function () {\n      // instead of actually loading the plugin at this stage,\n      // we will just pop its call into our internal call stack\n      // for use later. this is useful when we are stepping through\n      // an entire hoppfile but might only be running a single task\n\n      this.d.stack.push([\n        name,\n        [].slice.call(arguments)\n      ])\n\n      return this\n    }\n  })\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n  \n  init.all = createParallel\n  init.watch = createWatch\n\n  return init\n}\n"]}