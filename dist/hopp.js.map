{"version":3,"sources":["../src/hopp.js"],"names":["debug","require","directory","forEach","name","plugName","tmp","basename","i","length","toUpperCase","prototype","d","stack","push","slice","call","arguments","init","src","all","watch"],"mappings":";;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,MAAM,EAAEA,KAAF,KAAYC,QAAQ,aAAR,EAAuB,MAAvB,CAAlB;;AAEA;;;AAdA;;;;;;kBAiBe,MAAMC,SAAN,IAAmB;AAChC,GAAC,CAAC,MAAM,2BAAYA,SAAZ,CAAP,EAA+BC,OAA/B,CAAuCC,QAAQ;AAC9C,QAAIC,WAAW,EAAf;;AAEA,SAAK,IAAIC,MAAM,eAAKC,QAAL,CAAcH,IAAd,CAAV,EAA+BI,IAAI,CAAxC,EAA2CA,IAAIF,IAAIG,MAAnD,EAA2DD,KAAK,CAAhE,EAAmE;AACjEH,kBAAYC,IAAIE,CAAJ,MAAW,GAAX,GAAiBF,IAAIE,GAAJ,EAASE,WAAT,EAAjB,GAA0CJ,IAAIE,CAAJ,CAAtD;AACD;;AAEDR,UAAM,0BAAN,EAAkCK,QAAlC,EAA4CD,IAA5C;;AAEA;AACA;AACA,kBAAKO,SAAL,CAAeN,QAAf,IAA2B,YAAY;AACrC;AACA;AACA;AACA;;AAEA,WAAKO,CAAL,CAAOC,KAAP,CAAaC,IAAb,CAAkB,CAChBV,IADgB,EAEhB,GAAGW,KAAH,CAASC,IAAT,CAAcC,SAAd,CAFgB,CAAlB;;AAKA,aAAO,IAAP;AACD,KAZD;AAaD,GAxBA;;AA0BD;;;AAGA,QAAMC,OAAOC,OAAO,kBAASA,GAAT,CAApB;;AAEAD,OAAKE,GAAL;AACAF,OAAKG,KAAL;;AAEA,SAAOH,IAAP;AACD,C","file":"hopp.js","sourcesContent":["/**\n * @file src/hopp.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc..\n */\n\nimport path from 'path'\nimport Hopp from './tasks/mgr'\nimport createWatch from './tasks/watch'\nimport loadPlugins from './tasks/loadPlugins'\nimport createParallel from './tasks/parallel'\n\nconst { debug } = require('./utils/log')('hopp')\n\n/**\n * Create hopp object based on plugins.\n */\nexport default async directory => {\n  ;(await loadPlugins(directory)).forEach(name => {\n    let plugName = ''\n\n    for (let tmp = path.basename(name), i = 5; i < tmp.length; i += 1) {\n      plugName += tmp[i] === '-' ? tmp[i++].toUpperCase() : tmp[i]\n    }\n\n    debug('adding plugin %s from %s', plugName, name)\n    \n    // add the plugin to the hopp prototype so it can be\n    // used for the rest of the build process\n    Hopp.prototype[plugName] = function () {\n      // instead of actually loading the plugin at this stage,\n      // we will just pop its call into our internal call stack\n      // for use later. this is useful when we are stepping through\n      // an entire hoppfile but might only be running a single task\n\n      this.d.stack.push([\n        name,\n        [].slice.call(arguments)\n      ])\n\n      return this\n    }\n  })\n\n  /**\n   * Expose hopp class for task creation.\n   */\n  const init = src => new Hopp(src)\n  \n  init.all = createParallel\n  init.watch = createWatch\n\n  return init\n}\n"]}