{"version":3,"sources":["../../src/fs/glob.js"],"names":["cache","debug","require","statCache","tempCache","pattern","cwd","useDoubleCache","recache","Array","undefined","val","process","env","RECACHE","walk","pttn","directory","recursive","length","curr","shift","localResults","file","filepath","sep","fstat","isFile","hasOwnProperty","mtime","push","concat","isDirectory","results","Error","split"],"mappings":";;;;;;AAMA;;;;AACA;;;;AACA;;IAAYA,K;;AACZ;;;;;;AATA;;;;;;AAWA,MAAM,EAAEC,KAAF,KAAYC,QAAQ,cAAR,EAAwB,WAAxB,CAAlB;;AAEA,IAAIC,SAAJ;AACA,MAAMC,YAAY,EAAlB;;kBAEe,OAAOC,OAAP,EAAgBC,GAAhB,EAAqBC,iBAAiB,KAAtC,EAA6CC,UAAU,KAAvD,KAAiE;AAC9E;AACA,MAAI,EAAEH,mBAAmBI,KAArB,CAAJ,EAAiC;AAC/BJ,cAAU,CAACA,OAAD,CAAV;AACD;;AAED;AACA,MAAIF,cAAcO,SAAlB,EAA6B;AAC3BP,gBAAYH,MAAMW,GAAN,CAAU,IAAV,KAAmB,EAA/B;AACD;;AAED;AACAH,YAAUA,WAAWI,QAAQC,GAAR,CAAYC,OAAZ,KAAwB,MAA7C;;AAEA;;;AAGA,iBAAeC,IAAf,CAAoBC,IAApB,EAA0BC,SAA1B,EAAqCC,YAAY,KAAjD,EAAwD;AACtD,QAAIF,KAAKG,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACD;;AAED,UAAMC,OAAOJ,KAAKK,KAAL,EAAb;AACA,QAAIC,eAAe,EAAnB;;AAEArB,UAAM,8CAAN,EAAsDmB,IAAtD,EAA4DH,SAA5D,EAAuEC,SAAvE,EAAkFV,OAAlF;;AAEA,SAAK,IAAIe,IAAT,IAAkB,MAAM,eAAQN,SAAR,CAAxB,EAA6C;AAC3C;AACA,YAAMO,WAAWP,YAAY,eAAKQ,GAAjB,GAAuBF,IAAxC;;AAEA;AACA,UAAIG,KAAJ;;AAEA,UAAInB,cAAJ,EAAoB;AAClBmB,gBAAQtB,UAAUoB,QAAV,IAAsBpB,UAAUoB,QAAV,MAAuB,MAAM,YAAKA,QAAL,CAA7B,CAA9B;AACD,OAFD,MAEO;AACLE,gBAAQ,MAAM,YAAKF,QAAL,CAAd;AACD;;AAED;AACA,UAAI,yBAAMD,IAAN,EAAYH,IAAZ,CAAJ,EAAuB;AACrB,YAAIM,MAAMC,MAAN,EAAJ,EAAoB;AAClB,cAAInB,WAAW,CAACL,UAAUyB,cAAV,CAAyBJ,QAAzB,CAAZ,IAAkDrB,UAAUqB,QAAV,MAAwB,CAACE,MAAMG,KAArF,EAA4F;AAC1F1B,sBAAUqB,QAAV,IAAsB,CAACE,MAAMG,KAA7B;AACAP,yBAAaQ,IAAb,CAAkBN,QAAlB;AACD;AACF,SALD,MAKO;AACLF,yBAAeA,aAAaS,MAAb,EAAoB,MAAMhB,KAAKC,IAAL,EAAWQ,QAAX,EAAqBN,aAAaE,SAAS,IAA3C,CAA1B,EAAf;AACD;AACF,OATD,MASO,IAAIM,MAAMM,WAAN,MAAuBd,SAA3B,EAAsC;AAC3CI,uBAAeA,aAAaS,MAAb,EAAoB,MAAMhB,KAAK,CAACK,IAAD,EAAOW,MAAP,CAAcf,IAAd,CAAL,EAA0BQ,QAA1B,EAAoCN,SAApC,CAA1B,EAAf;AACD;AACF;;AAED,WAAOI,YAAP;AACD;;AAED;;;AAGA,MAAIW,UAAU,EAAd;AACA,OAAK,IAAIjB,IAAT,IAAiBX,OAAjB,EAA0B;AACxB,QAAIW,KAAK,CAAL,MAAY,GAAhB,EAAqB;AACnB,YAAM,IAAIkB,KAAJ,CAAU,8CAAV,CAAN;AACD;;AAEDD,cAAUA,QAAQF,MAAR,EAAe,MAAMhB,KAAKC,KAAKmB,KAAL,CAAW,GAAX,CAAL,EAAsB7B,GAAtB,CAArB,EAAV;AACD;;AAED;;;AAGAN,QAAMW,GAAN,CAAU,IAAV,EAAgBR,SAAhB;;AAEA;;;AAGA,SAAO8B,OAAP;AACD,C","file":"glob.js","sourcesContent":["/**\n * @file src/glob.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport path from 'path'\nimport match from 'minimatch'\nimport * as cache from '../cache'\nimport { readdir, stat } from './'\n\nconst { debug } = require('../utils/log')('hopp:glob')\n\nlet statCache\nconst tempCache = {}\n\nexport default async (pattern, cwd, useDoubleCache = false, recache = false) => {\n  // prefer arrays\n  if (!(pattern instanceof Array)) {\n    pattern = [pattern]\n  }\n\n  // get cache\n  if (statCache === undefined) {\n    statCache = cache.val('sc') || {}\n  }\n  \n  // allow overrides from the env\n  recache = recache || process.env.RECACHE === 'true'\n\n  /**\n   * Recursive walk.\n   */\n  async function walk(pttn, directory, recursive = false) {\n    if (pttn.length === 0) {\n      return\n    }\n\n    const curr = pttn.shift()\n    let localResults = []\n\n    debug('curr: %s, dir = %s, recur = %s, recache = %s', curr, directory, recursive, recache)\n\n    for (let file of (await readdir(directory))) {\n      // fix file path\n      const filepath = directory + path.sep + file\n\n      // get stat from temp cache (for non-watch tasks) or stat()\n      let fstat\n\n      if (useDoubleCache) {\n        fstat = tempCache[filepath] = tempCache[filepath] || await stat(filepath)\n      } else {\n        fstat = await stat(filepath)\n      }\n\n      // has been modified\n      if (match(file, curr)) {\n        if (fstat.isFile()) {\n          if (recache || !statCache.hasOwnProperty(filepath) || statCache[filepath] !== +fstat.mtime) {\n            statCache[filepath] = +fstat.mtime\n            localResults.push(filepath)\n          }\n        } else {\n          localResults = localResults.concat(await walk(pttn, filepath, recursive || curr === '**'))\n        }\n      } else if (fstat.isDirectory() && recursive) {\n        localResults = localResults.concat(await walk([curr].concat(pttn), filepath, recursive))\n      }\n    }\n\n    return localResults\n  }\n\n  /**\n   * Run all patterns against directory.\n   */\n  let results = []\n  for (let pttn of pattern) {\n    if (pttn[0] === '/') {\n      throw new Error('Not sure what to do with the / in your glob.')\n    }\n\n    results = results.concat(await walk(pttn.split('/'), cwd))\n  }\n\n  /**\n   * Update cache.\n   */\n  cache.val('sc', statCache)\n\n  /**\n   * Return final results object.\n   */\n  return results\n}\n"]}