{"version":3,"sources":["../../src/fs/index.js"],"names":["debug","require","useCache","promisify","fn","name","fnCall","args","slice","call","arguments","Promise","resolve","reject","apply","concat","err","cacheCall","disableFSCache","exists","dir","res","stat","mkdir","openFile","open","readdir","readFile","writeFile","tmpFile","file","fdpath","fd","mkdirp","directory","cwd","split","sep","String","indexOf"],"mappings":";;;;;;;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AATA;;;;;;AAWA,MAAM,EAAEA,KAAF,KAAYC,QAAQ,cAAR,EAAwB,SAAxB,CAAlB;;AAEA,IAAIC,WAAW,IAAf;;AAEA;;;;;AAKA,SAASC,SAAT,CAAmBC,EAAnB,EAAuBC,IAAvB,EAA6B;AAC3B;;;AAGA,QAAMC,SAAS,YAAY;AACzB,UAAMC,OAAO,GAAGC,KAAH,CAASC,IAAT,CAAcC,SAAd,CAAb;AACAV,UAAM,QAAN,EAAgBK,IAAhB,EAAsBE,IAAtB;AACA,WAAO,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCT,SAAGU,KAAH,CAAS,IAAT,EAAeP,KAAKQ,MAAL,CAAY,CAAC,UAAUC,GAAV,EAAe;AACzC,YAAIA,GAAJ,EAASH,OAAOG,GAAP,EAAT,KACKJ,QAAQE,KAAR,CAAc,IAAd,EAAoB,GAAGN,KAAH,CAASC,IAAT,CAAcC,SAAd,EAAyB,CAAzB,CAApB;AACN,OAH0B,CAAZ,CAAf;AAID,KALM,CAAP;AAMD,GATD;;AAWA;;;AAGA,QAAMO,YAAY,eAAKX,MAAL,CAAlB;;AAEA;;;AAGA,SAAO,YAAY;AACjB,QAAIJ,QAAJ,EAAc,OAAOe,UAAUH,KAAV,CAAgB,IAAhB,EAAsBJ,SAAtB,CAAP;AACd,WAAOJ,OAAOQ,KAAP,CAAa,IAAb,EAAmBJ,SAAnB,CAAP;AACD,GAHD;AAID;;AAED;;;AAGO,MAAMQ,0CAAiB,MAAM;AAClClB,QAAM,oBAAN;AACAE,aAAW,KAAX;AACD,CAHM;;AAKP;;;;AAIO,MAAMiB,0BAASC,OAAO,IAAIT,OAAJ,CAAYU,OAAO,aAAGF,MAAH,CAAUC,GAAV,EAAeC,GAAf,CAAnB,CAAtB;AACA,MAAMC,sBAAOnB,UAAU,aAAGmB,IAAb,EAAmB,MAAnB,CAAb;AACA,MAAMC,wBAAQpB,UAAU,aAAGoB,KAAb,EAAoB,OAApB,CAAd;AACA,MAAMC,8BAAWrB,UAAU,aAAGsB,IAAb,EAAmB,MAAnB,CAAjB;AACA,MAAMC,4BAAUvB,UAAU,aAAGuB,OAAb,EAAsB,SAAtB,CAAhB;AACA,MAAMC,8BAAWxB,UAAU,aAAGwB,QAAb,EAAuB,UAAvB,CAAjB;AACA,MAAMC,gCAAYzB,UAAU,aAAGyB,SAAb,EAAwB,WAAxB,CAAlB;;AAEP;;;AAGO,MAAMC,4BAAU,MAAM,IAAIlB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC5D,gBAAIiB,IAAJ,CAAS,CAACd,GAAD,EAAMe,MAAN,EAAcC,EAAd,KAAqB;AAC5B,QAAIhB,GAAJ,EAASH,OAAOG,GAAP,EAAT,KACKJ,QAAQ,CAACoB,EAAD,EAAKD,MAAL,CAAR;AACN,GAHD;AAID,CAL4B,CAAtB;;AAOP;;;AAGO,MAAME,0BAAS,eAAK,OAAOC,SAAP,EAAkBC,GAAlB,KAA0B;AACnD;AACAD,cAAYA,UAAUE,KAAV,CAAgB,eAAKC,GAArB,CAAZ;;AAEA;AACA,OAAK,IAAIjB,GAAT,IAAgBc,SAAhB,EAA2B;AACzB,QAAId,GAAJ,EAAS;AACP,UAAI;AACF,cAAMG,MAAMY,MAAM,eAAKE,GAAX,GAAiBjB,GAAvB,CAAN;AACD,OAFD,CAEE,OAAOJ,GAAP,EAAY;AACZ,YAAIsB,OAAOtB,GAAP,EAAYuB,OAAZ,CAAoB,QAApB,MAAkC,CAAC,CAAvC,EAA0C;AACxC,gBAAMvB,GAAN;AACD;AACF;AACF;;AAEDmB,WAAO,eAAKE,GAAL,GAAWjB,GAAlB;AACD;AACF,CAlBqB,CAAf","file":"index.js","sourcesContent":["/**\n * @file src/fs.js\n * @license MIT\n * @copyright 2017 10244872 Canada Inc.\n */\n\nimport fs from 'fs'\nimport tmp from 'tmp'\nimport path from 'path'\nimport { fn as wrap } from '../utils'\n\nconst { debug } = require('../utils/log')('hopp:fs')\n\nlet useCache = true\n\n/**\n * Similar to bluebird's Promise.promisify.\n * @param {Function} fn the async-callback function to transform\n * @return {Function} a new promise-based function\n */\nfunction promisify(fn, name) {\n  /**\n   * Create function call wrapper.\n   */\n  const fnCall = function () {\n    const args = [].slice.call(arguments)\n    debug('%s(%j)', name, args)\n    return new Promise((resolve, reject) => {\n      fn.apply(this, args.concat([function (err) {\n        if (err) reject(err)\n        else resolve.apply(null, [].slice.call(arguments, 1))\n      }]))\n    })\n  }\n\n  /**\n   * Create deterministic wrapper.\n   */\n  const cacheCall = wrap(fnCall)\n\n  /**\n   * Return conditional cache.\n   */\n  return function () {\n    if (useCache) return cacheCall.apply(this, arguments)\n    return fnCall.apply(this, arguments)\n  }\n}\n\n/**\n * Allow disabling of cache.\n */\nexport const disableFSCache = () => {\n  debug('Disabling fs cache')\n  useCache = false\n}\n\n/**\n * Transform only needed methods (instead of using mz\n * or doing a promisifyAll).\n */\nexport const exists = dir => new Promise(res => fs.exists(dir, res))\nexport const stat = promisify(fs.stat, 'stat')\nexport const mkdir = promisify(fs.mkdir, 'mkdir')\nexport const openFile = promisify(fs.open, 'open')\nexport const readdir = promisify(fs.readdir, 'readdir')\nexport const readFile = promisify(fs.readFile, 'readFile')\nexport const writeFile = promisify(fs.writeFile, 'writeFile')\n\n/**\n * Create temporary file.\n */\nexport const tmpFile = () => new Promise((resolve, reject) => {\n  tmp.file((err, fdpath, fd) => {\n    if (err) reject(err)\n    else resolve([fd, fdpath])\n  })\n})\n\n/**\n * mkdir -p\n */\nexport const mkdirp = wrap(async (directory, cwd) => {\n  // explode into separate\n  directory = directory.split(path.sep)\n\n  // walk\n  for (let dir of directory) {\n    if (dir) {\n      try {\n        await mkdir(cwd + path.sep + dir)\n      } catch (err) {\n        if (String(err).indexOf('EEXIST') === -1) {\n          throw err\n        }\n      }\n    }\n\n    cwd += path.sep + dir\n  }\n})\n"]}